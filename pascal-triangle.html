<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Validathor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #262626;
            color: #d0f0f0;
        }
        .triangle-container {
            max-width: 100%;
            overflow-x: scroll;
            padding: 20px;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            position: relative;
        }
        .triangle-wrapper {
            min-width: min-content;
            margin: 0 auto;
            padding: 0 50vw;
            box-sizing: border-box;
            position: relative;
        }
        .row {
            display: flex;
            justify-content: center;
            margin: 1px 0;
            white-space: nowrap;
            line-height: 1;
            position: relative;
            z-index: 2;
        }
        .row:nth-child(even) .number {
            color: #b0e0e6; /* Light teal */
        }
        .row:nth-child(odd) .number {
            color: #e0e0e0; /* Softer white */
        }
        .number {
            padding: 1px 0;
            margin: 0 1px;
            font-family: monospace;
            font-size: 12px;
            letter-spacing: -1px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        .number.selected {
            background-color: #a7ffea;
            border-radius: 2px;
        }
        .number.parallel {
            background-color: #4285F4; /* Google Blue */
        }
        .lines-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        h1 {
            text-align: center;
            color: #d0f0f0;
            margin: 20px 0;
        }
        .info {
            text-align: center;
            margin-bottom: 20px;
            color: #d0f0f0;
        }
        .button-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }
        .validate-button, .shuffle-button, .censor-button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            margin: 0 5px;
            border: 2px solid #ccc;
            background-color: #333;
            color: #d0f0f0;
            box-shadow: 2px 2px 0 #fff inset, -2px -2px 0 #aaa inset;
            font-family: 'Courier New', monospace;
        }
        .validate-button:active, .shuffle-button:active, .censor-button:active {
            box-shadow: -2px -2px 0 #fff inset, 2px 2px 0 #aaa inset;
        }
        .input-field {
            width: 60px;
            text-align: center;
            font-size: 16px;
            margin: 0 5px;
            border: 2px solid #ccc;
            background-color: #333;
            color: #d0f0f0;
            box-shadow: 2px 2px 0 #fff inset, -2px -2px 0 #aaa inset;
            font-family: 'Courier New', monospace;
        }
        .bottom-bar {
            display: none;
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #262626;
            justify-content: space-around;
            align-items: center;
            padding: 10px 0;
            z-index: 10;
            pointer-events: auto;
        }
        .bottom-bar button {
            flex: 1;
            text-align: center;
            font-size: 14px;
            border: none;
            background: none;
            cursor: pointer;
            color: #d0f0f0;
        }
        .bottom-bar i {
            display: block;
            font-size: 20px;
            margin-bottom: 3px;
        }
        .bottom-bar span {
            font-size: 10px;
        }
        .floating-input {
            display: none;
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #d0f0f0;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            z-index: 1000;
        }
        .floating-input input,
        .floating-input button {
            position: relative;
            z-index: 1001;
            pointer-events: auto;
        }
        .floating-input::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }
        @media (max-width: 768px) {
            .button-container {
                display: none;
            }
            .bottom-bar {
                display: flex;
            }
            .triangle-container {
                padding: 0;
                padding-bottom: 70px;
            }
        }
        .block-counter {
            position: fixed;
            right: 20px;
            top: calc(20px + 1em);
            font-family: monospace;
            color: #e0e0e0;
            font-size: 12px;
            z-index: 1000;
            padding: 10px;
        }
        .block-history {
            position: fixed;
            right: 20px;
            top: calc(20px + 1em + 40px);
            font-family: monospace;
            color: #b0e0e6;
            font-size: 12px;
            z-index: 1000;
            text-align: right;
        }
        .block-entry {
            margin: 2px 0;
        }
        .title {
            cursor: pointer;
            user-select: none;
        }
        
        .info-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            padding: 20px;
            color: #d0f0f0;
            font-family: monospace;
            white-space: pre-line;
            overflow-y: auto;
        }
        
        .info-content {
            max-width: 800px;
            margin: 20px auto;
            line-height: 1.5;
        }
        .title {
            text-align: center;
            color: #d0f0f0;
            margin: 20px 0;
            user-select: none;
        }
        .info-icon {
            font-size: 0.6em;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        .info-icon:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1 class="title">The Validathor <i class="fas fa-circle-question info-icon" onclick="toggleInfoOverlay()"></i></h1>
    <div id="infoOverlay" class="info-overlay" onclick="toggleInfoOverlay()">
        <div class="info-content">
[Go online] - shuffle a chosen amount of txns into your mempool.
[Validate] - create blocks of length 3, 7, 11 or 13 (prime factors of 3003).
Blocks are created by selecting sequential txns from adjacent rows.
- Must select from next row up or down
- Position within row doesn't matter
- Same block pattern cannot be validated twice

[Censor] - burn a txn (ARC54) to prevent others from completing blocks.

Total possible blocks: 278 out of 531,017 combinations

Block Statistics:
Length 3:
  Base blocks: 148
  Position-aware combinations: 185,925

Length 7:
  Base blocks: 72
  Position-aware combinations: 178,605

Length 11:
  Base blocks: 40
  Position-aware combinations: 121,275

Length 13:
  Base blocks: 18
  Position-aware combinations: 45,212

Be the first to validate a unique block pattern to win rewards!

        </div>
    </div>
    <div class="button-container">
        <button class="shuffle-button" onclick="shuffleNormalTxns()">Go online</button>
        <input type="number" class="input-field" id="shuffleInput" min="1" placeholder="0">
        <button class="validate-button" onclick="validateSelectedBlock()">Validate</button>
        <button class="censor-button" onclick="censorSelectedTxn()">Censor</button>
    </div>
    <div class="triangle-container" id="container">
        <div class="lines-container" id="lines"></div>
        <div class="triangle-wrapper" id="triangle"></div>
    </div>
    <div class="block-counter">[0]</div>
    <div class="block-history"></div>
    <div class="bottom-bar">
        <button onclick="showFloatingInputField()"><i class="fas fa-dice"></i><span>Go online</span></button>
        <button onclick="validateSelectedBlock()"><i class="fas fa-link"></i><span>Validate</span></button>
        <button onclick="censorSelectedTxn()"><i class="fas fa-ban"></i><span>Censor</span></button>
    </div>
    <div class="floating-input" id="floatingInput">
        <input type="number" class="input-field" id="mobileShuffleInput" min="1" placeholder="0">
        <button onclick="shuffleMobileTxns()">OK</button>
    </div>

    <script>
        // DOM element IDs
        const DOM_IDS = {
            SHUFFLE_INPUT: 'shuffleInput',
            MOBILE_SHUFFLE_INPUT: 'mobileShuffleInput',
            TRIANGLE: 'triangle',
            CONTAINER: 'container',
            LINES: 'lines',
            INFO_OVERLAY: 'infoOverlay',
            FLOATING_INPUT: 'floatingInput'
        };

        // Initialize constants first
        const MAX_ROW = 77;
        const TOTAL_TXNS = calculateTotalTxns(MAX_ROW);
        const VALID_BLOCK_SIZES = getPrimeFactors(TOTAL_TXNS);
        const DARK_THEME_COLORS = generateDistinctColors(278);

        // Initialize variables
        let ownedTxns = new Set();
        let remainingTxns = TOTAL_TXNS;
        let currentBlock = [];
        let allBlocks = [];
        let alertShown = false;

        // CSS classes we use in JavaScript (for reference)
        const CSS_CLASSES = {
            CENSORED: 'censored',
            VALIDATED: 'validated',
            SELECTED: 'selected',
            NUMBER: 'number'
        };

        // Calculate total number of transactions in the triangle
        function calculateTotalTxns(rows) {
            return (rows * (rows + 1)) / 2;
        }

        // Find prime factors of a number
        function getPrimeFactors(n) {
            const factors = [];
            let divisor = 2;
            
            while (n > 1) {
                if (n % divisor === 0) {
                    factors.push(divisor);
                    n = n / divisor;
                } else {
                    divisor++;
                }
            }
            
            return [...new Set(factors)]; // Remove duplicates
        }

        function isValidNextNumber(lastNumber, newNumber) {
            const newRow = parseInt(newNumber.getAttribute('data-row'));

            // If transaction is censored or already validated, it's never valid
            if (newNumber.classList.contains('censored') || newNumber.classList.contains('validated')) {
                return false;
            }

            // If this is the first number in the block, any non-censored, non-validated number is valid
            if (currentBlock.length === 0) {
                return true;
            }

            // Check if the new number is already in the block
            const isAlreadyInBlock = currentBlock.some(elem => 
                parseInt(elem.getAttribute('data-row')) === newRow
            );
            if (isAlreadyInBlock) {
                return false;
            }

            // Check if the new number is adjacent to ANY number in the current block
            return currentBlock.some(existingNumber => {
                const existingRow = parseInt(existingNumber.getAttribute('data-row'));
                return Math.abs(newRow - existingRow) === 1;
            });
        }

        function resetCurrentBlock() {
            // Remove highlighting from all numbers in current block
            currentBlock.forEach(element => {
                element.classList.remove('selected');
            });
            
            // Clear lines for the current block
            updateBlockLines();

            // Reset the block
            currentBlock = [];
            updateBlockCounter(0);
        }

        function drawBlockLine(elem1, elem2) {
            const rect1 = elem1.getBoundingClientRect();
            const rect2 = elem2.getBoundingClientRect();
            const containerRect = document.getElementById('lines').getBoundingClientRect();

            const line = document.createElement('div');
            line.style.position = 'absolute';
            line.style.backgroundColor = '#ffffe4';
            line.style.height = '2px';
            line.style.opacity = '0.6';

            const x1 = (rect1.left + rect1.right) / 2 - containerRect.left;
            const x2 = (rect2.left + rect2.right) / 2 - containerRect.left;
            const y1 = (rect1.top + rect1.bottom) / 2 - containerRect.top;
            const y2 = (rect2.top + rect2.bottom) / 2 - containerRect.top;

            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);

            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}rad)`;
            line.style.transformOrigin = '0 0';

            document.getElementById('lines').appendChild(line);
        }

        function updateBlockLines() {
            const linesContainer = document.getElementById('lines');
            linesContainer.innerHTML = '';

            // Draw lines for current block
            if (currentBlock.length > 0) {
                for (let i = 0; i < currentBlock.length; i++) {
                    for (let j = i + 1; j < currentBlock.length; j++) {
                        const row1 = parseInt(currentBlock[i].getAttribute('data-row'));
                        const row2 = parseInt(currentBlock[j].getAttribute('data-row'));
                        // Only draw lines between adjacent numbers
                        if (Math.abs(row1 - row2) === 1) {
                            drawBlockLine(currentBlock[i], currentBlock[j]);
                        }
                    }
                }
            }

            // Draw lines for validated blocks
            allBlocks.forEach(block => {
                for (let i = 0; i < block.length; i++) {
                    for (let j = i + 1; j < block.length; j++) {
                        const row1 = parseInt(block[i].getAttribute('data-row'));
                        const row2 = parseInt(block[j].getAttribute('data-row'));
                        if (Math.abs(row1 - row2) === 1) {
                            drawBlockLine(block[i], block[j]);
                        }
                    }
                }
            });
        }

        function handleTxnClick(event) {
            const element = event.target;
            
            // Check if transaction is owned and not already validated or censored
            if (!ownedTxns.has(element) || 
                element.classList.contains('validated') || 
                element.classList.contains('censored')) {
                alert('This txn is not in mempool');
                return;
            }
            
            if (currentBlock.length > 0) {
                // Check if this is a valid next number
                if (!isValidNextNumber(currentBlock[currentBlock.length - 1], element)) {
                    resetCurrentBlock();
                    updateBlockLines();
                    return;
                }
            }

            // If element is already in block, reset from that point
            const existingIndex = currentBlock.indexOf(element);
            if (existingIndex !== -1) {
                // Remove all elements after this one
                const elementsToRemove = currentBlock.slice(existingIndex + 1);
                elementsToRemove.forEach(elem => elem.classList.remove('selected'));
                currentBlock = currentBlock.slice(0, existingIndex + 1);
                updateBlockLines();
                return;
            }

            element.classList.add('selected');
            currentBlock.push(element);
            updateBlockLines();
            
            // Draw line to previous number if exists
            if (currentBlock.length > 1) {
                drawBlockLine(currentBlock[currentBlock.length - 2], element);
            }

            // Update block counter
            updateBlockCounter(currentBlock.length);
        }

        function validateSelectedBlock() {
            // Get sorted row numbers for current block
            const currentRows = currentBlock.map(element => 
                element.getAttribute('data-row')
            ).sort().join('-');

            // Check if the block has already been validated
            const isDuplicate = allBlocks.some(block => {
                // Get sorted row numbers for existing block
                const blockRows = block.map(element =>
                    element.getAttribute('data-row')
                ).sort().join('-');
                
                // Compare sorted blocks
                return blockRows === currentRows;
            });

            if (isDuplicate) {
                alert('This block has already been validated.');
                resetCurrentBlock();
                return;
            }

            if (VALID_BLOCK_SIZES.includes(currentBlock.length)) {
                addBlockHistory(currentBlock);
                alert('Valid block!');
                const color = DARK_THEME_COLORS[Math.floor(Math.random() * DARK_THEME_COLORS.length)];
                currentBlock.forEach(element => {
                    element.classList.remove('selected');
                    element.style.backgroundColor = color;
                    element.classList.add('validated');
                });
                allBlocks.push([...currentBlock]);
                currentBlock = [];
                updateBlockLines();
            } else {
                alert('Invalid block size. Must be one of: ' + VALID_BLOCK_SIZES.join(', '));
                resetCurrentBlock();
            }

            // Reset counter after validation (success or failure)
            updateBlockCounter(0);
        }

        function shuffleTxnsToMempool(inputElement, isMobile = false) {
            const num = parseInt(inputElement.value, 10);

            if (isNaN(num) || num < 1) {
                alert('Minimum stake is one!');
                return;
            }
            if (num > remainingTxns) {
                alert(`Only ${remainingTxns} txns available!`);
                return;
            }

            if (isMobile) {
                const floatingInput = document.getElementById(DOM_IDS.FLOATING_INPUT);
                floatingInput.style.display = 'none';
                document.getElementById(DOM_IDS.CONTAINER).style.pointerEvents = 'auto';
            }

            // Update remaining txns
            remainingTxns -= num;
            
            // Get all available positions
            const allPositions = document.querySelectorAll('.number');
            const availablePositions = Array.from(allPositions).filter(pos => 
                !ownedTxns.has(pos) &&     // Changed from ownedPositions
                !pos.classList.contains('censored') && 
                !pos.classList.contains('validated')
            );
            
            // Check if there are enough positions to select
            if (availablePositions.length < num) {
                alert(`Not enough available positions!`);
                remainingTxns += num; // Restore the count if we can't complete the shuffle
                return;
            }

            // Randomly assign txns to positions
            for (let i = 0; i < num; i++) {
                const randomIndex = Math.floor(Math.random() * availablePositions.length);
                const selectedPosition = availablePositions.splice(randomIndex, 1)[0];
                ownedTxns.add(selectedPosition);    // Changed from ownedPositions
                
                // Highlight positions with owned txns
                selectedPosition.style.opacity = '1';
            }
            
            // Dim positions without txns
            allPositions.forEach(pos => {
                if (!ownedTxns.has(pos)) {    // Changed from ownedPositions
                    pos.style.opacity = '0.3';
                }
            });

            alert(`Going online with ${num} txn in the mempool! (${remainingTxns} txns remaining)`);
            
            // Clear the input field
            inputElement.value = '';
        }

        // Usage for normal view
        function shuffleNormalTxns() {
            const input = document.getElementById(DOM_IDS.SHUFFLE_INPUT);
            shuffleTxnsToMempool(input);
        }

        // Usage for mobile view
        function shuffleMobileTxns() {
            const input = document.getElementById(DOM_IDS.MOBILE_SHUFFLE_INPUT);
            shuffleTxnsToMempool(input, true);
        }

        function showFloatingInputField() {
            const floatingInput = document.getElementById(DOM_IDS.FLOATING_INPUT);
            const inputField = document.getElementById(DOM_IDS.MOBILE_SHUFFLE_INPUT);
            floatingInput.style.display = 'block';
            document.getElementById(DOM_IDS.CONTAINER).style.pointerEvents = 'none';
            inputField.focus();
        }

        function censorSelectedTxn() {
            // Check if a transaction is selected
            if (currentBlock.length === 0) {
                if (!alertShown) {
                    alertShown = true;
                    alert('Select txn!');
                    setTimeout(() => alertShown = false, 100); // Reset flag after a short delay
                }
                return;
            }

            // Get the last selected transaction
            const selectedTxn = currentBlock[currentBlock.length - 1];

            // Check if the selected txn is owned and not part of a validated block
            if (!ownedTxns.has(selectedTxn)) {
                alert('Txn not in mempool!');
                return;
            }
            if (selectedTxn.classList.contains('validated')) {
                alert('Txn must be in mempool');
                return;
            }

            // Set flag to prevent "Select txn" alert
            alertShown = true;
            
            // Alert for censoring transaction
            alert('Censoring transaction!');

            // Strike through the text of the txn to indicate it is censored
            selectedTxn.style.textDecoration = 'line-through';
            selectedTxn.classList.add('censored');

            // Remove highlighting from the txn
            selectedTxn.classList.remove('selected');
            selectedTxn.style.backgroundColor = ''; // Reset background color if used for highlighting

            // Filter out the censored txn from current block to prevent its use in block validation
            currentBlock = currentBlock.filter(txn => txn !== selectedTxn);
            updateBlockLines();

            // Reset alert flag after a delay
            setTimeout(() => alertShown = false, 100);
        }

        // Ensure buttons are only clickable when a transaction is selected
        document.querySelectorAll('.censor-button, .bottom-bar button:nth-child(3)').forEach(button => {
            button.removeEventListener('click', censorSelectedTxn); // Remove any existing listeners
            button.addEventListener('click', censorSelectedTxn, { once: true }); // Add the listener once
        });

        function generatePascalTriangle() {
            const triangle = [];
            const container = document.getElementById(DOM_IDS.TRIANGLE);

            // Generate triangle rows
            for (let i = 0; i < MAX_ROW; i++) {
                const currentRow = [];
                for (let j = 0; j <= i; j++) {
                    if (j === 0 || j === i) {
                        currentRow.push(1);
                    } else {
                        const prevRow = triangle[i - 1];
                        const num = prevRow[j - 1] + prevRow[j];
                        currentRow.push(num);
                    }
                }
                triangle.push(currentRow);
            }

            // Display the triangle
            triangle.forEach((row, n) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'row';
                
                row.forEach((num, r) => {
                    const numSpan = document.createElement('span');
                    numSpan.className = 'number';
                    numSpan.textContent = `(${String(n).padStart(2,'0')}${String(r).padStart(2,'0')})`;
                    numSpan.setAttribute('data-row', n);
                    numSpan.setAttribute('data-col', r);
                    
                    numSpan.addEventListener('click', handleTxnClick);
                    
                    rowDiv.appendChild(numSpan);
                });
                
                container.appendChild(rowDiv);
            });

            // Center the triangle after it's generated
            const containerElement = document.getElementById(DOM_IDS.CONTAINER);
            containerElement.scrollLeft = (containerElement.scrollWidth - containerElement.clientWidth) / 2;
        }

        function updateBlockCounter(count) {
            const counter = document.querySelector('.block-counter');
            counter.textContent = `[${count}]`;
        }

        function addBlockHistory(block) {
            const history = document.querySelector('.block-history');
            const firstNum = block[0].getAttribute('data-row').padStart(2, '0') + 
                           block[0].getAttribute('data-col').padStart(2, '0');
            const lastNum = block[block.length - 1].getAttribute('data-row').padStart(2, '0') + 
                          block[block.length - 1].getAttribute('data-col').padStart(2, '0');
            const blockSize = block.length;
            const entry = document.createElement('div');
            entry.className = 'block-entry';
            entry.textContent = `[0x${firstNum}${lastNum}${String(blockSize).padStart(2, '0')}]`;
            history.insertBefore(entry, history.firstChild);
        }

        function generateDistinctColors(count) {
            const colors = [];
            const GOLDEN_RATIO = 0.618033988749895;
            let hue = Math.random();

            for (let i = 0; i < count; i++) {
                hue = (hue + GOLDEN_RATIO) % 1;
                const color = `hsl(${Math.floor(hue * 360)}, 85%, 70%)`;
                colors.push(color);
            }
            return colors;
        }

        document.addEventListener('click', function(event) {
            // If click is outside any number element, reset everything
            if (!event.target.classList.contains('number')) {
                resetCurrentBlock();
                updateBlockLines();
            }
        });

        // Event handlers
        window.onload = function initializeApp() {  // Named the function for clarity
            generatePascalTriangle();
            
            // Set max values for input fields
            document.getElementById(DOM_IDS.SHUFFLE_INPUT).max = TOTAL_TXNS;
            document.getElementById(DOM_IDS.MOBILE_SHUFFLE_INPUT).max = TOTAL_TXNS;
            
            // Add event listeners for Enter key
            document.getElementById(DOM_IDS.SHUFFLE_INPUT).addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    shuffleNormalTxns();
                }
            });

            document.getElementById(DOM_IDS.MOBILE_SHUFFLE_INPUT).addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    shuffleMobileTxns();
                }
            });
        };

        window.onresize = updateBlockLines;  // Using our renamed function

        function toggleInfoOverlay() {
            const overlay = document.getElementById(DOM_IDS.INFO_OVERLAY);
            if (overlay.style.display === 'block') {
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'block';
            }
        }
    </script>
</body>
</html>
